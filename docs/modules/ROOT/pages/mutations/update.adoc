[[mutations-update]]
= Update

Using the following type definitions for these examples:

[source, graphql, indent=0]
----
type Post {
    id: ID! @id
    content: String!
    creator: User! @relationship(type: "HAS_POST", direction: IN)
}

type User {
    id: ID! @id
    name: String
    posts: [Post!]! @relationship(type: "HAS_POST", direction: OUT)
}
----

The following update Mutations and response types will be generated for the above type definitions:

[source, graphql, indent=0]
----
type UpdatePostsMutationResponse {
    posts: [Post!]!
}

type UpdateUsersMutationResponse {
    users: [User!]!
}

type Mutation {
    updatePosts(
        where: PostWhere
        update: PostUpdateInput
        connect: PostConnectInput
        disconnect: PostDisconnectInput
        create: PostCreateInput
        delete: PostDeleteInput
    ): UpdatePostsMutationResponse!
    updateUsers(
        where: UserWhere
        update: UserUpdateInput
        connect: UserConnectInput
        disconnect: UserDisconnectInput
        create: UserCreateInput
        delete: UserDeleteInput
    ): UpdateUsersMutationResponse!
}
----

> The `id` field not be update-able as the xref::type-definitions/autogeneration.adoc#type-definitions-autogeneration-id[`@id`] directive has been used.

== Single update

Say you wanted to edit the content of a Post:

[source, graphql, indent=0]
----
mutation {
    updatePosts(
        where: {
            id: "892CC104-A228-4BB3-8640-6ADC9F2C2A5F"
        }
        update: {
            content: "Some new content for this Post!"
        }
    ) {
        posts {
            content
        }
    }
}
----

== Nested create

Instead of creating a Post and connecting it to a User, you could update a User and create a Post as part of the Mutation:

[source, graphql, indent=0]
----
mutation {
    updateUsers(
        where: { name: "John Doe" }
        create: {
            posts: [
                { node: { content: "An interesting way of adding a new Post!" } }
            ]
        }
    ) {
        users {
            id
            name
            posts {
                content
            }
        }
    }
}
----

== `connectOrCreate` relationships
If a related node has a `@unique` or `@id` directive defined, `connectOrCreate` can be used in a nested update to perform a `MERGE` operation on the related node, creating a new relationship and the related node if it doesn't exist.

Consider the following type definitions:

[source, graphql, indent=0]
----
type Actor {
    name: String!
    movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}

type Movie {
    title: String
    id: ID! @id
    actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN)
}
----

Because a movie ID is unique, `connectOrCreate` can be used in an Actor mutation to ensure a movie exists before connecting. Note that only `@unique` or `@id` fields can be used in `where`:

[source, graphql, indent=0]
----
mutation {
  updateActors(
    update: {
        movies: {
          connectOrCreate: {
            where: { node: { id: "1234" } }
            onCreate: { node: { title: "Forrest Gump" } }
          }
        }
    },
    where: { name: "Tom Hanks" }
  ) {
    info {
      nodesCreated
    }
  }
}
----

In this case, all actors matching `"Tom Hanks"` will be connected to the Movie with id `"1234"`. If the movie with given ID does not exist, it will be created with the title `"Forrest Gump"`.

For update operations, `connectOrCreate` can also be used as a top-level input:

[source, graphql, indent=0]
----
mutation {
  updateActors(
      connectOrCreate: {
        movies: {
            where: { node: { id: "1234" } }
            onCreate: { node: { title: "Forrest Gump" } }
        }
      },
      where: { name: "Tom Hanks" }
  ) {
    info {
      nodesCreated
    }
  }
}
----

This operation is equivalent to the previous example.

[[array-methods]]
= Array methods

Array methods allow us to modify existing property arrays in Update mutations within these entities:

* `Node`
* `Nested Nodes`
* `Relationship properties`
* `Interfaces`

The following operators are available:

* `_POP`
* `_PUSH`

The POP operator expects a single Int value as input

The PUSH operator conforms to the type of input defined in the type definition.

== Examples

=== Array pop
Suppose we have the following type definition, a Movie with a property array called tags:

[source, graphql, indent=0]
----
type Movie {
    title: String
    tags: [String]
}
----

We can pop from this `tags` property array.

Before: `['a', 'b', 'c']`

After: `['a', 'b']`


[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_POP: 1 }) {
        movies {
            title
            tags
        }
    }
}
----

Or, for more than one property from the array:

Before: `['a', 'b', 'c']`

After: `['a']`

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_POP: 2 }) {
        movies {
            title
            tags
        }
    }
}
----

Similarly, you can have multiple array property fields and update them in the same query:


[source, graphql, indent=0]
----
type Movie {
    title: String
    tags: [String]
    moreTags: [String]
}
----

We can pop from both the `tags` and `moreTags` property arrays.


Before: 
```
    tags: ['a', 'b', 'c']
    moreTags: ['x', 'y', 'z']
```

After:
```
    tags: ['a', 'b']
    moreTags: ['x']
```

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_POP: 1, moreTags_POP: 2 }) {
        movies {
            title
            tags
            moreTags
        }
    }
}
----

=== Array push
Suppose we have the following type definition, a Movie with a property array called tags:

[source, graphql, indent=0]
----
type Movie {
    title: String
    tags: [String]
}
----

We can push to this `tags` property array.


Before: `['some tag']`

After: `['some tag', 'another tag']`

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_PUSH: "another tag" }) {
        movies {
            title
            tags
        }
    }
}
----

Or push multiple elements in a single update:

Before: `['some tag']`

After: `['some tag', 'another tag', 'one more tag']`

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_PUSH: ["another tag", "one more tag"] }) {
        movies {
            title
            tags
        }
    }
}
----

Similarly, you can have multiple array property fields and update them in the same query:

[source, graphql, indent=0]
----
type Movie {
    title: String
    tags: [String]
    moreTags: [String]
}
----

We can push to both the `tags` and `moreTags` property arrays.

Before:
```
    tags: ['some tag']
    moreTags: []
```

After:
```
    tags: ['some tag', 'another tag']
    moreTags ['a different tag']
```

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_PUSH: "another tag", moreTags_PUSH: "a different tag" }) {
        movies {
            title
            tags
            moreTags
        }
    }
}
----

=== Array push and pop in one update

It is possible to perform both a push and pop operation in one Update mutation.

Suppose we have the following type definition, a Movie with a property array called tags:

[source, graphql, indent=0]
----
type Movie {
    title: String
    tags: [String]
    moreTags: [String]
}
----

We can then update both property arrays with either _POP or _PUSH operators.

Before:
```
    tags: ['some tag']
    moreTags: []
```

After:
```
    tags: []
    moreTags ['a different tag']
```

[source, graphql, indent=0]
----
mutation {
    updateMovies (update: { tags_POP: 1, moreTags_PUSH: "a different tag" }) {
        movies {
            title
            tags
            moreTags
        }
    }
}
----
